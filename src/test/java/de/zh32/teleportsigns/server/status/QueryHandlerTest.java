package de.zh32.teleportsigns.server.status;

import lombok.Getter;
import org.junit.Test;

import java.io.*;
import java.net.InetSocketAddress;

import static org.hamcrest.Matchers.*;
import static org.junit.Assert.assertThat;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

/**
 * @author zh32
 */
public class QueryHandlerTest {

	private QueryHandler testee;

	public ServerListPing.ServerConnection mockConnection(Response type) {
		ServerListPing.ServerConnection connection = mock(ServerListPing.ServerConnection.class);
		when(connection.getDataOutputStream()).thenReturn(new DataOutputStream(mock(OutputStream.class)));
		when(connection.getDataInputStream()).thenReturn(new DataInputStream(new ByteArrayInputStream(type.getBytes())));
		when(connection.getHost()).thenReturn(new InetSocketAddress("localhost", 25555));
		return connection;
	}

	@Test
	public void can_handle_minecraft19_protocol() throws Exception {
		testee = new QueryHandler(mockConnection(Response.MC19));
		testee.doHandShake();
		StatusResponse response = testee.doStatusQuery();
		assertThat(
				response,
				allOf(
						hasProperty("description",
								is(equalTo("A Minecraft Server"))
						),
						hasProperty("version", allOf(
								hasProperty("name", is(equalTo("1.9.2"))),
								hasProperty("protocol", is(equalTo(109)))
						))
				)
		);
	}

	@Test
	public void can_handle_minecraft18_protocol() throws Exception {
		testee = new QueryHandler(mockConnection(Response.MC18));
		testee.doHandShake();
		StatusResponse response = testee.doStatusQuery();
		assertThat(
				response,
				allOf(
						hasProperty("description",
								is(equalTo("A Minecraft Server"))
						),
						hasProperty("version", allOf(
								hasProperty("name", is(equalTo("Spigot 1.8"))),
								hasProperty("protocol", is(equalTo(47)))
						))
				)
		);
	}

	private enum Response {
		MC18(new byte[]{
				0x74, 0x00, 0x72, 0x7b, 0x22, 0x64, 0x65, 0x73,
				0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e,
				0x22, 0x3a, 0x22, 0x41, 0x20, 0x4d, 0x69, 0x6e,
				0x65, 0x63, 0x72, 0x61, 0x66, 0x74, 0x20, 0x53,
				0x65, 0x72, 0x76, 0x65, 0x72, 0x22, 0x2c, 0x22,
				0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x73, 0x22,
				0x3a, 0x7b, 0x22, 0x6d, 0x61, 0x78, 0x22, 0x3a,
				0x32, 0x30, 0x2c, 0x22, 0x6f, 0x6e, 0x6c, 0x69,
				0x6e, 0x65, 0x22, 0x3a, 0x30, 0x7d, 0x2c, 0x22,
				0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x22,
				0x3a, 0x7b, 0x22, 0x6e, 0x61, 0x6d, 0x65, 0x22,
				0x3a, 0x22, 0x53, 0x70, 0x69, 0x67, 0x6f, 0x74,
				0x20, 0x31, 0x2e, 0x38, 0x22, 0x2c, 0x22, 0x70,
				0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x22,
				0x3a, 0x34, 0x37, 0x7d, 0x7d, 0x09, 0x01, 0x00,
				0x00, 0x01, 0x4b, (byte) 0xac, (byte) 0xc2, 0x63, 0x30
		}),
		MC19(new byte[]{
				0x79, 0x00, 0x77, 0x7b, 0x22, 0x64, 0x65, 0x73,
				0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e,
				0x22, 0x3a, 0x7b, 0x22, 0x74, 0x65, 0x78, 0x74,
				0x22, 0x3a, 0x22, 0x41, 0x20, 0x4d, 0x69, 0x6e,
				0x65, 0x63, 0x72, 0x61, 0x66, 0x74, 0x20, 0x53,
				0x65, 0x72, 0x76, 0x65, 0x72, 0x22, 0x7d, 0x2c,
				0x22, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x73,
				0x22, 0x3a, 0x7b, 0x22, 0x6d, 0x61, 0x78, 0x22,
				0x3a, 0x32, 0x30, 0x2c, 0x22, 0x6f, 0x6e, 0x6c,
				0x69, 0x6e, 0x65, 0x22, 0x3a, 0x30, 0x7d, 0x2c,
				0x22, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e,
				0x22, 0x3a, 0x7b, 0x22, 0x6e, 0x61, 0x6d, 0x65,
				0x22, 0x3a, 0x22, 0x31, 0x2e, 0x39, 0x2e, 0x32,
				0x22, 0x2c, 0x22, 0x70, 0x72, 0x6f, 0x74, 0x6f,
				0x63, 0x6f, 0x6c, 0x22, 0x3a, 0x31, 0x30, 0x39,
				0x7d, 0x7d, 0x09, 0x01, 0x00, 0x00, 0x01, 0x53,
				(byte) 0xff, (byte) 0xdb,
				(byte) 0xf9, (byte) 0xea
		});

		@Getter
		private final byte[] bytes;

		Response(byte[] bytes) {
			this.bytes = bytes;
		}
	}

}
